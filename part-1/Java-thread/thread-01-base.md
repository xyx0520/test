# <font color="orange">多线程：基础</font>

## 1. 认识线程

现代化操作系统都是采用『**多任务**』和『**分时**』设计，从而诞生了『**程序**』和『**进程**』的概念，而后又进一步诞生了『**线程**』的概念。

> 从历史的时间线来看，『**进程**』在前，『**线程**』在后。

『**程序**』是对数据描述与操作的代码的集合。

『**进程**』是程序的一次动态执行的过程，它对应了从代码加载、执行至执行完毕的一个完整过程。这个过程也是进程从产生、发展至消亡的过程。

> 通俗地说，『程序』是死的，『进程』是活的。进程就是『**活着的**』程序。

『**运行程序**』也被称作『**执行任务**』,一个操作系统中可以同时运行多个程序也就是同时执行『**多个任务**』，那么每个任务就对应一个进程。

在操作系统的管控下，多个进程『**轮流**』使用 CPU 资源<small>（和其他公共资源）</small>，这被称作『**分时**』。

> 通俗地说，站在 CPU 的角度而言，**根本不存在所谓的同时**。这一点很重要。

进程的特点：

- 进程是操作系统运行程序的基本单元；

- 每一个进程都有自己独立的一块内存空间和一组系统资源；

- 每一个进程的内部数据和状态是完全独立的。

## 2. 线程

『线程』是更现代化的概念和技术<small>（它的诞生晚于进程）</small>。线程是『**进程中**』的一个单位，即，一个进程可以有多个线程<small>（至少有一个），简单来说，就是 `一对多` 的关系</small>。

线程是进程中执行运算的最小单元，一个进程在其执行过程中可以产生多个线程，而线程必须在某个进程内执行。

线程是进程内部的一个执行单元，是可以完成一个独立任务的顺序控制流程。如果在一个进程中同时运行了多个线程，用来完成不同的工作，则称之为『**多线程**』。

线程和进程既有联系又有区别：

- 一个进程中至少要有一个线程；

- 操作系统将资源分配给进程，同一个进程的所有线程共享该进程的所有资源；

- 操作系统将 CPU 分配给线程，即真正在 CPU 上运行的上线程。

**每个线程都有一个『执行方法』**<small>（也叫『**入口方法**』）</small>，每个进程至少拥有的、自动拥有的那个线程的执行方法毫无疑问就是 **main** 方法，因此这个线程也被成为『**主线程**』。

每个线程的任务、使命就是去执行它的执行方法。<small>线程的执行方法的结束，即意味着线程的生命、使命的完结。</small>

创建并使用线程的过程可以分为 4 个步骤：

1. 定义一个线程类，同时指明这个线程的执行方法

2. 创建线程对象

3. 启动线程

4. 终止线程

定义一个线程类通常有两种方法：继承 **java.lang.Thread** 类和实现 **java.lang.Runnable** 接口。


## 3. 使用 Thread 类创建线程

Java 提供了 java.lang.Thread 类支持多线程编程，该类提供了大量的方法来控制和操作线程。

| # | 说明 |
| :- | :- |
| run 方法 | 直接调用线程的执行函数 |
| start 方法 | 启动线程 |
| sleep 方法 | 让线程休眠<small>（即让出 CPU）</small>指定 **毫秒** 数|
| getName 方法 | 返回该线程的名称 |
| getPriority 方法 | 返回线程的优先级 |
| setPriority 方法 | 更改线程的优先级 |
| getState 方法 | 返回该线程的状态 |
| isAlive 方法 | 测试线程是否处于活动状态 |
| join 方法 | 等待该线程终止 |
| interrupt 方法 | 中断线程 |
| yield 方法 | 暂停正在执行的线程，并执行其他线程 |

使用继承 Thread 类的方式创建线程的实现步骤如下：

1. 定义一个类去继承 Thread 类，重写 **Thread#run** 方法，在 **Thread#run** 方法中实现代码逻辑；

2. 创建线程对象;

3. 调用 **Thread#start** 方法启动线程。

## 4. 使用 Runnable 接口创建线程

由于 Java 只允许单继承，因此一旦一个类已有父类，那么就无法再继承 Thread 类，从而导致上述实现线程的方式无法使用。

使用 Runnable 接口创建线程能解决上述问题。

Runnable 接口声明了一个 **Runnable#run** 方法。任何一个类都可以通过实现 Runnable 接口并实现其 **Runnable#run** 方法来完成线程的所有活动。

使用实现 Runnable 接口的方式创建线程的实现步骤如下：

1. 定义 Xxx 类并实现 java.lang.Runnable 接口，并实现它所声明的 **run** 方法；

2. 创建线程对象；

3. 调用 **start** 方法启动线程。


## 5. 线程的状态

线程的核心状态有 3 个：

- 可执行<small>（Runnable）</small>
- 执行中<small>（Running）</small>
- 阻塞中<small>（Blocking）</small>

在加上线程创建之处的短暂的『新生』状态<small>（Created）</small>和销毁前的短暂的『僵尸』状态<small>（Zombie）</small>，从而组成了最常见的线程的 5 种状态。

<dl>
<dt>新生状态：Created</dt>
<dd>创建线程对象后，而又未调用其 Thread#start 方法之前，该线程处于这种状态。此时操作系统还未为其分配资源。</dd>
<dd>此时只能启动和终止线程，任何而其他操作都会发生议程。</dd>
</dl>

<dl>
<dt>可执行状态：Runnable</dt>
<dd>当调用 Thread#start 之后，操作系统为该线程分配了所必须的资源，但是而又未获得 CPU 执行机会时，该线程处于这种状态。</dd>
<dd>由于 CPU 时稀缺的公共资源，毫无疑问，在多线程程序中，任意时刻有大量的线程都是处于这种状态。</dd>
<dd>通俗的说，这种状态就是『万事俱备，只欠东风』。</dd>
</dl>

<dl>
<dt>执行状态：Running</dt>
<dd>当前获得 CPU 资源，正在执行的线程，就是处于这种状态。</dd>
<dd>对于单核 CPU 而言，一个进程中无论有多少线程，任意时刻有且仅有一个线程是处于该状态。</dd>
<dd>同理，对于多核 CPU 而言，<small>（全系统无论多少进程多少线程）</small>N 核 CPU 有且仅有 N 个线程处于这种状态。</dd>
</dl>

<dl>
<dt>阻塞状态：Blocked</dt>
<dd>一个正在运行（Running）的线程因为某种原因代码逻辑无法再继续运行下去了，就进入阻塞状态。</dd>
<dd>进入阻塞状态的线程会让出 CPU，因为即便它强占 CPU 也无法再继续运行下去。</dd>
<dd>当造成该线程阻塞的原因小时后，该线程将又有机会运行。</dd>
<dd>通俗的说，这种状态就是『除了欠东风，还欠别的』。</dd>
</dl>

导致一个线程阻塞最常见的原因有以下几个：

- 调用了 Thread 类的静态方法 Thread#sleep ;

- 线程执行 IO 时，无数据可读（或无空间可写）；

- 一个线程的执行需要获得一个『锁』，而此时锁正被别的线程占用。

<dl>
<dt>僵尸状态：Zombie</dt>
<dd>一个线程在结束执行后（无论是正常执行完执行函数，还是被终止掉了），在系统回收分配给它的资源之前，该进程短暂地处于这种状态。</dd>
</dl>


## 6. 线程的调用


### 6.1 线程的优先级（了解、自学）

当一个时刻有多个线程处于可运行状态，它们需要排队等待 CPU 资源，每个线程会自动获得一个线程的优先级<small>（Priority）</small>，优先级的高低反映线程的重要或紧急程序。

可运行状态<small>（Runnable）</small>的线程按优先级排队，线程调度依据建立在优先级基础上的『先到先服务』原则。

> 线程的调度是操作系统的重要功能和职责。
> 
> 线程调度的规则依赖于操作系统内核的实现。有的操作系统会充分遵守优先级规则，有的系统只是将优先级当做『**建议值**』，而有的操作系统则完全没有优先级概念、无视优先级，完全随机。
> 
> **所以不能以优先级作为控制线程先后执行顺序的手段！**

线程的优先级用 1 ... 10 表示，10 表示优先级最高，默认值是 5。Thread 类中有对应的静态常量：NORM_PRIORITY、MIN_PRIORITY、MAX_PRIORITY 。

线程的优先级可以通过 **Thread#setPriority(int level)** 方法更改。

### 6.2 实现线程调度的方法

线程调度的实现核心思路只有一个：**通过各种手段，迫使一个线程<small>（通常是当前执行线程）</small>让出 CPU ，从而让其它线程拥有执行机会**。

-   手段一：**Thread#join** 方法

    Thread#join 方法会导致当前线程阻塞<small>（让出 CPU）</small>，等待调用该方法的线程<small>（即，Thread 对象所代表的那个线程）</small>结束后再继续执行本线程。

-   手段二：**Thread.sleep** 方法

    Thread.sleep 方法会导致当前线程睡眠<small>（本质上也是阻塞，迫使当前线程让出 CPU）</small>，在指定时间到期后，重新进入可运行状态。

-   手段三：**Thread.yield** 方法

    Thread.yield 方法稍微有点不同，它让当前线程让出 CPU ，但并不是进入阻塞状态，而是直接进入 Runnable 状态。

需要注意的是，当前线程让出 CPU 之后，接下来是哪个线程执行<small>（从 Runnable 状态变为 Running 状态）</small>带有『**不确定性**』。


### 6.3 线程的同步与互斥

当两个或多个线程需要访问同一资源<small>（或执行同一段代码时）</small>，需要某一时刻只能被一个线程使用的方式，称为线程『**互斥**』。

当两个或多个线程以互斥的方式访问完同一资源<small>（或执行同一段代码）</small>后，『通知』其他线程的方式，称为线程『**同步**』。

> 同步与互斥通常总是一起出现的。只出现互斥，不出现同步，意味着代码逻辑是一种极简单的多线程状况。

### 6.4 synchronized 关键字

使用 **synchronized** 关键字修饰的方法控制对类成员变量的访问。每个类实例都对应一把锁，方法一旦执行，就独占该锁，直到方法结束时才将锁释放；此后其它被阻塞的线程才能获得该锁，重新进入可执行状态。

这种机制保证了同一时刻，对于每一个实例，其所声明为 synchronized 的方法只能有一个处于可执行状态，从而有效地避免了类成员变量的访问冲突。

语法：

```java
访问修饰符 synchronized 返回类型 方法名 () {
    ...
} 
```

或 

```java
synchronized 访问修饰符 返回类型 方法名 () {
    ...
} 
```

synchronized 方法的缺陷在于：如果将一个耗时的方法声明为 synchronized 将会使其它线程阻塞时间过长，从而影响系统执行效率和用户体验。

同步代码块是同步方法的缺陷的解决方案，它『锁住』的不是整个方法，而是方法中的一个代码片段。

语法：

```java
synchronized (一个对象) {
    ...
}
```

这里的『一个对象』通常是一个字符串常量对象。


## 7. 锁 

Java 并发 API 对『**锁**』提供了支持。锁是一些对象，它们为 synchronized 提供了替代方案。

**锁<small>（Lock）</small>** 不仅能实现 synchronized 的互斥功能，还能进一步实现线程间的同步功能。

锁的工作原理如下：在访问共享资源之前，申请用于保护资源的锁；当资源访问结束完成时，释放锁。当某个线程正在使用锁时，如果另一个线程尝试申请锁，那么后者将会阻塞等待，直到锁被前者释放位置。

> 锁的作用，逻辑上，就是一个令牌、通行证。持有这个令牌、通行证的线程才能继续执行。没有这个令牌、通行证的线程，无法继续执行，直到令牌的持有者放下令牌，而被它拿到后，它才能继续执行。

所有的锁都要实现 **Lock** 接口，最常用的 Lock 接口的实现类是 **ReentrantLock** 。

| 方法 | 描述 |
| -------------- | ---------------------- |
| void lock()    | 进行等待，直到可以获得锁为止 |
| void lockInterruptibly() throws ...   | 除非被中断，否则进行等待，直到可以获得锁为止  |
| Condition newCondition()  | 返回与调用锁关联的 Condition 对象  |
| boolean tryLock()  | 尝试获得锁，如果锁不可获得，立即返回 false；如果可获得，返回 true  |
| boolean tryLock(long wait, TimeUnit unit) throws ... | 在指定时间内，尝试获得锁。如果超出时间后仍无法获得，则返回 false；如果可获得，则返回 true |
| void unlock()   |  释放锁       |

ReentrantLock 实现了一种可重入锁，当前持有锁的线程能够重复进入这种锁。当然，对于线程重入锁而言，所有 lock ( ) 调用必须有相同数量的 unlock ( ) 调用进行抵消。

