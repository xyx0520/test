# <font color="orange">系统安装的预备知识</font>

## 1. 主分区和逻辑分区

『**主分区**』和『**逻辑分区**』的概念的区别，以及『**扩展分区**』概念的引出，都是历史发展过程中的产物。

**DOS** 和 **FAT** 文件系统<small>（它们是最早出现的广为流行的个人 PC 上的文件系统）</small>的早期设计思路是支持最多 24 个分区，可用盘符从 **C** 到 **Z** 。<small>（`A` 和 `B` 两个盘符固定分配给了软驱）。</small>

但是这个设定很快和另一个设定冲突了：MBR<small>（主引导记录）</small>的分区表中最多只能存放 4 个分区的相关信息。

为了避免被『打脸』<small>（ 24 VS 4）</small>，**DOS** 和 **FAT** 提出了一个方案：你可以将多个分区『**装**』进一个<small>（概念上的）</small>容器中把它们『**当作**』一个整体。这样，N 个分区就变成了 1 个分区。

> 通过这种方案，别说 24 个分区硬凑成 4 个分区，就是 240 个分区你都能硬凑成 4 个分区。

这样，被『装』进这个<small>（概念上的）</small>容器中的各个分区就被称为『**逻辑分区**』。它们这个整体，也就是这个容器被称为『**扩展分区**』。

有些分区独立存在的，不用和别的分区硬凑进扩展分区中的分区就被称为『**主分区**』。

这样`凑四`的方案就可以有很多种了。<small>当然，你也『**不一定非得用满 4 个分区**』。</small>方案很多，无穷无尽，随手例如：

| # | 方案一 | 方案二 | 方案三 |
| :-: | :-    | :-    | :- |
| 1 | 主分区 | 主分区 | 主分区 |
| 2 | 主分区 | 主分区 |扩展分区，<br><small>它由 5 个逻辑分区组成</small> |
| 3 | 主分区 | 扩展分区，<br><small>它由 10 个逻辑分区组成</small> | 扩展分区，<br><small>它由 10 个逻辑分区组成</small> |
| 4 | 扩展分区，<br><small>它由 21 个逻辑分区组成</small> | 扩展分区，<br><small>它由 12 个逻辑分区组成</small> | 扩展分区，<br><small>它由 8 个逻辑分区组成</small> |


再强调一遍，如果你本身没有那么多的分区需求，你完全可以就是直接 4 个主分区<small>（或更少的主分区）</small>，简单粗暴。


| # | 方案一 | 方案二 | 方案三 | 方案四 |
| :-: | :-    | :-    | :- | :- |
| 1 | 主分区 | 主分区 | 主分区 | 主分区 |
| 2 | 主分区 | 主分区 | 主分区 | 无 |
| 3 | 主分区 | 主分区 |  无   | 无 |
| 4 | 主分区 | 无    |  无   | 无 |


---

## 分区的编号

在 Windows 中，各个分区都有盘符表示，从 **C** 到 **Z**。在 Linux 中则使用的是数字编号，并且人为规定编号有『主分区』和『逻辑分区』之分：

- 『**主分区**』使用数字：1、2、3、4

- 『**逻辑分区**』使用数字：5、6、7、8、...

> 在 Windows 中，作为『逻辑分区』的容器，『**扩展分区**』这个概念十分明显，在不少些地方你会看到『扩展分区』这个名词。
> 
> 但是在 Linux 中，扩展分区概念十分弱化，一般你面对的都是『**主分区**』、『**逻辑分区**』这两个概念。

当然，如果你没有那么多主分区，那么中间的某些数字可能会跳过。因为第一个逻辑分区的编号必定是 5 。

例如，上述的方案二，你得到的各个分区的数字编号将是：1、2、5、6、7、... 。


## 2. 开机启动和 boot loader 

计算机的开机启动有固定的流程：

1. 主板通电后执行主板中的 BIOS，去执行某些任务；

2. BIOS 最后会加载『**硬盘第一个扇区**』<small>（512 个字节）</small>中的代码；<small>至此，BIOS<small>（在本次启动中）</small>的任务使命结束。</small>

   硬盘第一个扇区的 512 个字节中有 2 部分内容：

    - 前 446 字节中是被称为 **boot loader** 的程序的代码；

    - 后 64 字节中最多可存放 4 个分区的相关信息（8 x 4 字节）；
    
    - 最后 2 个字节是固定的标志 0x55AA 。
  
3. BIOS 结束运行后，**boot loader** 开始运行。**boot loader** 的使命和任务就是加载操作系统镜像并运行。

4. boot loader 加载了操作系统镜像之后，它（在本次启动过程中的）使命就结束了。

5. 操作系统开始运行，电脑的控制权就交到了操作系统手里。


boot loader 是一类软件的总称<small>（角色、身份）</small>。Windows 使用的 boot loader 是 **`windows boot manager`**，Linux 使用的 boot loader 是 **`grub2`** 。

![boot-loader](./img/boot-loader.png)


---

从上面的开机启动过程可以看到，开机无法进入系统的原因通常有：


- BIOS 坏了<small>（这个可能性极低）</small>。

- 硬盘的第一个扇区中的内容不正确，因此 BIOS 无法加载 boot loader，无法进入下一个环节。

- boot loader 没有发现你电脑上有系统镜像，或者，没有发现你电脑上的全部系统镜像。


---

毫无疑问，一台电脑上，boot loader 软件有且仅需要一个。`windows boot manager` 或者是 `grub2` 。

不过，有可能你有意或无意中遇到特殊情况。例如，你的电脑是双硬盘，你在两块硬盘上分别安装 Windows 和 Linux 双系统，并且将它们对应的 boot loader 也在两个硬盘上各装了一个。

对于这种情况，无论你有多少个硬盘，其上又有多少个 boot loader，BIOS 总是按照先后顺序挨个在各个硬盘上查找是否存在 boot loader，如果有，则加载，运行，并且不再查找下一个硬盘。

当然，你可以在 BIOS 中去设置硬盘的优先级，从而决定使用哪个硬盘上所安装的 boot loader。但是本质上这里始终是只有一个 boot loader 在起作用。
